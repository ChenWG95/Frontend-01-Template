'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var configFileTs = require('config-file-ts');
var child_process = require('child_process');
var events = require('events');
var glob = _interopDefault(require('glob'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var util = _interopDefault(require('util'));
var yargs = _interopDefault(require('yargs'));

const execPm = util.promisify(child_process.exec);
/** Execute a command in a subprocess.
 *
 * stdio is inherited from our process.
 *
 * @return a promise containing the return code of the command.
 */
async function run(cmdLine) {
    const { cmd, args } = splitCmdLine(cmdLine);
    const childProc = child_process.spawn(cmd, args, { stdio: "inherit" });
    const promisedResult = events.once(childProc, "exit").then(([result]) => result);
    return promisedResult;
}
function splitCmdLine(cmdLine) {
    const all = mkArgs(cmdLine);
    const cmd = all[0];
    const args = all.slice(1);
    return {
        cmd,
        args,
    };
}
/** split up a string containing command line arguments
 * @returns an array suitable for spawn or exec
 */
function mkArgs(line) {
    const words = /(?:[^\s"]+|"[^"]*")+/g;
    const matched = line.match(words);
    return [...matched];
}

/** Parse and validate command line and config parameters */
function scriptysParams(args) {
    const params = parseScriptysArgs(args);
    if (!params) {
        return undefined;
    }
    const config = getConfiguration(params);
    if (!config) {
        console.error("tys configuration not understood", args);
        return undefined;
    }
    const { tsFile, otherTsFiles, outDir, command } = config;
    const exist = configFileTs.expectFilesExist([tsFile]);
    if (!exist) {
        console.error(`scriptysParams: ${tsFile} not found`);
        return undefined;
    }
    const sources = [tsFile, ...otherSources(otherTsFiles)];
    const realOutDir = outDir || tysDefaultOutDir(tsFile);
    const fullCommand = commandToRun(tsFile, realOutDir, params.commandArgs, command);
    return {
        tsFile,
        sources,
        realOutDir,
        fullCommand
    };
}
/**
 * Parse command line arguments for scriptys
 * @param args command line argument array
 * @param _launcher  (for tests) override launch command name (normally argv[0])
 */
function parseScriptysArgs(args, _launcher) {
    const rawLauncher = _launcher || yargs.parse("").$0;
    const launcher = path.basename(rawLauncher);
    if (launcher === "tys" || launcher === "tys.js") {
        return tysArguments(args);
    }
    return nonTysArguments(launcher, args);
}
/** Interpret arguments when launched as tys */
function tysArguments(args) {
    const [tysArgs, commandArgs] = splitAtDDash(args);
    const yargArgs = tysLocalArgs(tysArgs);
    const unparsed = yargArgs._.slice();
    const config = configParameter(yargArgs.config);
    let tsFile;
    const { command, outDir, otherTsFiles } = yargArgs;
    if (!config) {
        tsFile = unparsed.shift();
    }
    commandArgs.push(...unparsed);
    const parsedArgs = {
        config,
        tsFile,
        otherTsFiles,
        outDir,
        command,
        commandArgs
    };
    return parsedArgs;
}
/** When not launched as tys (e.g. as gulptys) arguments go directly to command
 * and config file is based on name, e.g. gulptys.config.ts.
 */
function nonTysArguments(launcher, args) {
    const config = launcher + ".config.ts";
    return {
        config,
        commandArgs: args
    };
}
/** split a set of arguments before and after a "--"  */
function splitAtDDash(args) {
    const found = args.findIndex(s => s === "--");
    if (found !== -1) {
        const before = args.slice(0, found);
        const after = args.slice(found + 1);
        return [before, after];
    }
    return [args, []];
}
function tysLocalArgs(args) {
    return yargs
        .option("config", {
        alias: "c",
        string: true,
        describe: "tys configuration file"
    })
        .option("otherTsFiles", {
        string: true,
        array: true,
        describe: "additional typescript files (glob syntax)"
    })
        .option("command", {
        string: true,
        describe: "command to run after compiling"
    })
        .option("outDir", {
        string: true,
        describe: "directory for compiled js files"
    })
        .help()
        .usage("$0 tsFile \n$0 -c [tysConfigFile]\nsymLinkToTys   # uses symlinkToTys.config.ts as config")
        .parse(args);
}
function configParameter(config) {
    if (typeof config === "string" && config.length > 0) {
        return config;
    }
    else {
        return undefined;
    }
}
function otherSources(otherTsGlobs) {
    const sources = [];
    if (otherTsGlobs) {
        for (const tsGlob of otherTsGlobs) {
            sources.push(...glob.sync(tsGlob));
        }
    }
    return sources;
}
function commandToRun(tsFile, realOutDir, cmdArgs, command) {
    const jsPath = configFileTs.jsOutFile(tsFile, realOutDir);
    const realCmd = command || `node ${jsPath}`;
    return `${realCmd} ${cmdArgs}`;
}
const launcherArg = /^(?:node|yarn|npm)$/;
function isLauncherArg(arg) {
    return path.basename(arg).match(launcherArg) !== null;
}
function getConfiguration(params) {
    const { config, tsFile, otherTsFiles, command, outDir } = params;
    if (config) {
        let configPath = config;
        if (!fs.existsSync(config) && !path.isAbsolute(config)) {
            configPath = path.join(__dirname, config);
            if (!fs.existsSync(configPath)) {
                console.log("config not found:", config, configPath);
                return undefined;
            }
        }
        return configFileTs.loadTsConfig(configPath);
    }
    else if (tsFile) {
        return {
            tsFile,
            outDir,
            command,
            otherTsFiles
        };
    }
    else {
        console.error("no tsFile no config.tys.ts");
        return undefined;
    }
}
function stripLauncherArgs(argv) {
    if (isLauncherArg(argv[0])) {
        return argv.slice(2);
    }
    else {
        return argv.slice(1);
    }
}
function tysDefaultOutDir(tsFile) {
    return configFileTs.defaultOutDir(path.resolve(tsFile), "tys");
}

/* sriptys (or tys for short) is a launcher to run TypeScript on node.
 * It supports caching and scripts split over multiple source files.
 *
 * Tys can be also configured to launch scripts other than the one being compiled
 * which is handy to compile config files for other tools.
 */
/** Launch scriptys
 *
 * @param argv array containing launcher program name, and command line arguments
 * @returns the result of the executed script
 */
async function scriptysArgv(argv) {
    const args = stripLauncherArgs(argv);
    return runScriptys(args);
}
/** Launch scriptys
 * @param cmdLine command line arguments to tys
 * @returns the result of the executed script
 */
async function scriptysCommandLine(cmdLine) {
    const args = cmdLine.split(/\s+/);
    return runScriptys(args);
}
/** @return the output path to a .js file compiled from a .ts file */
function locateJsOut(tsFile, outDir) {
    const realOutDir = outDir || tysDefaultOutDir(tsFile);
    return configFileTs.jsOutFile(tsFile, realOutDir);
}
/** Launch scriptys
 *
 * @param args command line arguments
 * @returns the result of the executed script
 */
async function runScriptys(args) {
    const params = scriptysParams(args);
    if (!params) {
        return Promise.reject(`invalid scriptys parameters: ${args}`);
    }
    const { sources, realOutDir, fullCommand } = params;
    const built = configFileTs.compileIfNecessary(sources, realOutDir);
    if (!built) {
        return Promise.resolve(-2);
    }
    return run(fullCommand);
}

exports.locateJsOut = locateJsOut;
exports.run = run;
exports.runScriptys = runScriptys;
exports.scriptysArgv = scriptysArgv;
exports.scriptysCommandLine = scriptysCommandLine;
exports.stripLauncherArgs = stripLauncherArgs;
//# sourceMappingURL=scriptys.js.map
